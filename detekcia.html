<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title></title>
	<style type="text/css">
		body, textarea{
			font-family: arial;
		}

		main{
			position: relative;
		}

		span.pointer{
			display: none;
			width: 20px;
			height: 20px;
			background: red;
			position: absolute;
		}

		span.mock {
			position: absolute;
			top:  0;
			left:  600px;
			/*visibility: hidden;*/
			display: inline-block;
		}
		

	</style>
</head>
<body>
	<h1>Textarea test</h1>
	<main>
		<textarea rows="10" cols="60">Joujou asd asd asd asd asd asd</textarea>
		<span class="pointer"></span>
		<span class="mock"></span>
	</main>
	<div>Tu je dalsi obsah</div>

<script type="text/javascript">
	const textarea = document.querySelector('textarea');
	const pointer = document.querySelector('span.pointer');
	const mock = document.querySelector('span.mock');


	// initialize so the mock looks same way as real textarea
	const taStyles = getComputedStyle(textarea);

	mock.style.border = '1px solid black';
	mock.style.display = 'inline-block';
	mock.style.maxWidth = taStyles['width'];
	mock.style.wordWrap = taStyles['word-wrap']
	
	mock.style.paddingTop = taStyles['padding-top'];
	mock.style.paddingBottom = taStyles['padding-bottom'];
	mock.style.paddingLeft = taStyles['padding-left'];
	mock.style.paddingRight = taStyles['padding-right'];

	mock.style.fontFamily = taStyles['font-family'];
	mock.style.fontSize = taStyles['font-size'];
	mock.style.fontStyle = taStyles['font-style'];
	mock.style.fontWeight = taStyles['font-weight'];

	mock.style.lineHeight = taStyles['line-height'];
	mock.style.color = taStyles['color'];
	

	let tagging = false;
	let tagCursor = null;
	let token = null;


	/* 
		ked napisem zavinac - otvori sa popup
		ked kliknem mimo zavinaca - zavrie sa popup
		ked sipkami odidem od zavinaca - zavrie sa popup
		ked sa sipkami vratim ku zavinaci - otvori sa popup
	*/

	let lastLength = null;

	textarea.addEventListener('keyup', (e) => {
		const cursor = getCursor(e.target);
			
		console.log('keyup', e);
		
		console.log('keyup2', {cursor, tagCursor, tagChar: e.target.value[tagCursor], char: e.target.value[cursor - 1]});

		if(e.key === '@' || e.target.value[cursor - 1] === '@'){
			tagging = true;
			
			tagCursor = cursor - 1;
			token = ''

			console.log('keyup3', {cursor, tagCursor, tagChar: e.target.value[tagCursor], char: e.target.value[cursor - 1]});

			showPopup(tagCursor);
		}else if(tagCursor !== null){

			if( e.target.value[tagCursor] !== '@'){
				console.log('poloha zavinaca sa zmenila');
				console.log([e.target.value[tagCursor - 2], e.target.value[tagCursor - 1], e.target.value[tagCursor], e.target.value[tagCursor + 1], e.target.value[tagCursor + 2]].join());


				const offset = e.target.value.length - lastLength;

				console.log({offset});
				if(tagCursor > 0 && e.target.value[tagCursor - offset] === '@'){
					console.log('nieco sme pred zavinacom zmazali')
					tagCursor-= offset;
					if(tagging) showPopup(tagCursor);
					// showPopup(tagCursor);

				}else if(tagCursor <= e.target.value.length - offset && e.target.value[tagCursor + offset] === '@'){
					console.log('nieco sme pred zavinacom pridali')
					tagCursor+= offset;	
					if(tagging) showPopup(tagCursor);
					// tagging = true;
					// showPopup(tagCursor);
				}else {
					tagCursor = null;
					tagging = false;
					hidePopup();
				}
			}

			const firstSpaceAfterCursor = e.target.value.indexOf(' ', tagCursor);

			if(	tagging && (firstSpaceAfterCursor >= 0 && cursor >= firstSpaceAfterCursor) || cursor <= tagCursor){
				tagging = false;
				hidePopup();	
			}

			if(!tagging && cursor > tagCursor && (firstSpaceAfterCursor < 0 || (firstSpaceAfterCursor >= 0 && cursor <= firstSpaceAfterCursor))){
				tagging = true;
				showPopup(tagCursor);
			}

			if(firstSpaceAfterCursor >= 0){
				token = e.target.value.substr(tagCursor + 1, firstSpaceAfterCursor - tagCursor);	
			}else{
				token = e.target.value.substr(tagCursor + 1);	
			}
		}


		console.log('after', {cursor, tagCursor, char: e.target.value[tagCursor], key: e.key});

		lastLength = e.target.value.length;
	})

	textarea.addEventListener('click', (e) => {
		if(tagCursor === null) return;

		const cursor = getCursor(e.target);
		const firstSpaceAfterCursor = e.target.value.indexOf(' ', tagCursor);

		console.log('click', {tagCursor, cursor, firstSpaceAfterCursor});

		if (cursor < tagCursor || (firstSpaceAfterCursor >= 0 && cursor > firstSpaceAfterCursor)){
			hidePopup();
			tagging = true;
		} else if (cursor > tagCursor && (firstSpaceAfterCursor < 0 || cursor < firstSpaceAfterCursor ) ){
			tagging = false;
			showPopup(tagCursor);
		}
	})

	function showPopup(cursor){
		console.log('showing popup', cursor);
		const coords = getCursorCoords(cursor);

		pointer.style.display = 'block';
		pointer.style.left = coords.left + 'px';
		pointer.style.top = (coords.top - 20) + 'px';
	}

	function hidePopup(){
		pointer.style.display = 'none';
	}


	function getCursor(input){
		const cursor = getCursorPos(input);

		if(cursor.start) return cursor.start;

		else return cursor;
	}

	function getCursorPos(input) {
	    if ("selectionStart" in input && document.activeElement == input) {
	        return {
	            start: input.selectionStart,
	            end: input.selectionEnd
	        };
	    }
	    else if (input.createTextRange) {
	        var sel = document.selection.createRange();
	        if (sel.parentElement() === input) {
	            var rng = input.createTextRange();
	            rng.moveToBookmark(sel.getBookmark());
	            for (var len = 0;
	                     rng.compareEndPoints("EndToStart", rng) > 0;
	                     rng.moveEnd("character", -1)) {
	                len++;
	            }
	            rng.setEndPoint("StartToStart", input.createTextRange());
	            for (var pos = { start: 0, end: len };
	                     rng.compareEndPoints("EndToStart", rng) > 0;
	                     rng.moveEnd("character", -1)) {
	                pos.start++;
	                pos.end++;
	            }
	            return pos;
	        }
	    }
	    return -1;
	}
   

	function getCursorCoords(cursor){
		const {value} = textarea;
		// get all lines before cursor
		const linesBeforeCursor = value.substring(0, cursor).split('\n');
		

		let tmpCursor = cursor;
		while(!(/\s/.test(value[tmpCursor]) || /\n/.test(value[tmpCursor])) && tmpCursor < value.length) {
			tmpCursor++;
		}

		const cursorShift = tmpCursor - cursor;

		//console.log(cursorShift);


		const linesBeforeTmpCursor = value.substring(0, tmpCursor).split('\n');

		const linesBeforeCursorCount = linesBeforeCursor.length - 1;

		const filteredLinesBeforeCursor = linesBeforeCursor.filter((line, i) => (i < linesBeforeCursorCount))

		const valueOfLinesBeforeCursor = filteredLinesBeforeCursor.length > 1 ? filteredLinesBeforeCursor.join("<br/>") + '<br/>' : filteredLinesBeforeCursor.join("<br/>");

		const lineWithCursor = linesBeforeCursor[linesBeforeCursor.length - 1];
		const fullLineWithCursor = linesBeforeTmpCursor[linesBeforeTmpCursor.length - 1];
		


		// set pointer position
		// console.log({lineWithCursor, fullLineWithCursor});

		// return;

		mock.innerHTML = fullLineWithCursor;
		let lineWithCursorHeight = mock.offsetHeight;

		
		let wrappedLastLineLength = 0
		let wrappedLineLength = 1;
		let wrappedLines = 0

		let tmpLineWithCursor = fullLineWithCursor;
		let tmpLineWithCursorHeight = lineWithCursorHeight;

		//console.log({fullLineWithCursor});
		// return;

		let lastWhiteSpace = 0;

		do{
			//console.log('testujem medzeru', fullLineWithCursor[fullLineWithCursor.length - wrappedLineLength]);
			if(/\s/.test(fullLineWithCursor[fullLineWithCursor.length - wrappedLineLength])){
				lastWhiteSpace = wrappedLineLength;
			}
			//console.log({wrappedLineLength, lastWhiteSpace});
			
			wrappedLineLength++;


			tmpLineWithCursor = fullLineWithCursor.substring(0, fullLineWithCursor.length - wrappedLineLength)

			mock.innerHTML = tmpLineWithCursor;
			tmpLineWithCursorHeight = mock.offsetHeight;

			// console.log(lineWithCursorHeight, tmpLineWithCursorHeight, lineWithCursorHeight > tmpLineWithCursorHeight);
			if(lineWithCursorHeight > tmpLineWithCursorHeight){
				// console.log('wrap', tmpLineWithCursor, tmpLineWithCursorHeight);
					

				const restOfWord = fullLineWithCursor.substr(fullLineWithCursor.length - wrappedLineLength, wrappedLineLength - lastWhiteSpace);

				//console.log('idem pridavat zvysok slova', '`' + restOfWord + '`');
				


				//potrebujem pridat tolko whitespacov, kolko je v poslednom slove
				mock.innerHTML = (tmpLineWithCursor + restOfWord).replace(' ', '&nbsp;');
				const tmpLineWithCursorWithSpaceHeight = mock.offsetHeight;
				//console.log(tmpLineWithCursorWithSpaceHeight,tmpLineWithCursorHeight)

		
				if(tmpLineWithCursorWithSpaceHeight > tmpLineWithCursorHeight){
					//console.log('este by som nemal wrappovat');					

					// debugger;
				}else{
					//console.log('wrapujem');
					//console.log({wrappedLineLength});

					// debugger;
					
					if(wrappedLines === 0){
						wrappedLastLineLength = wrappedLineLength - restOfWord.length;
					}
					wrappedLines++;
					lineWithCursorHeight = tmpLineWithCursorHeight;
				}

			}

			// debugger;
		}while(tmpLineWithCursor.length > 0);

		if(wrappedLines === 0){
			// nemam viac riadkov
			// console.log('"' + lineWithCursor.replace(/\s/g, '&nbsp;') + '"');

			mock.innerHTML = valueOfLinesBeforeCursor;
			const top = (mock.offsetHeight - parseInt(taStyles['padding-bottom']));

			mock.innerHTML = lineWithCursor.replace(/\s/g, '&nbsp;');
			const left = (mock.offsetWidth - parseInt(taStyles['padding-right']));

			return {top, left};

		}else{
			// mam viac riadkov

			mock.innerHTML = lineWithCursor.substr(0, lineWithCursor.length - (wrappedLastLineLength + 1)).replace(' ', '&nbsp;');;
			const top = (mock.offsetHeight - parseInt(taStyles['padding-bottom']));
		
			mock.innerHTML = lineWithCursor.substr(-1 * (wrappedLastLineLength - cursorShift)).replace(/\s/g, '&nbsp;');
			const left = (mock.offsetWidth - parseInt(taStyles['padding-right']));
		
			return {top, left};
		}
	}



</script>
</body>
</html>	